set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" " alternatively, pass a path where Vundle should install plugins
" "call vundle#begin('~/some/path/here')
"
" " let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'
"
" " The following are examples of different formats supported.
" " Keep Plugin commands between vundle#begin/end.
" " plugin on GitHub repo
" Plugin 'tpope/vim-fugitive'
" " plugin from http://vim-scripts.org/vim/scripts.html
" Plugin 'L9'
" " Git plugin not hosted on GitHub
" Plugin 'git://git.wincent.com/command-t.git'
" " git repos on your local machine (i.e. when working on your own plugin)
" Plugin 'file:///home/gmarik/path/to/plugin'
" " The sparkup vim script is in a subdirectory of this repo called vim.
" " Pass the path to set the runtimepath properly.
" Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
" " Avoid a name conflict with L9
" Plugin 'user/L9', {'name': 'newL9'}
"
Plugin 'majutsushi/tagbar.git'
" " All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" " To ignore plugin indent changes, instead use:
" "filetype plugin on
" "
" " Brief help
" " :PluginList       - lists configured plugins
" " :PluginInstall    - installs plugins; append `!` to update or just
" :PluginUpdate
" " :PluginSearch foo - searches for foo; append `!` to refresh local cache
" " :PluginClean      - confirms removal of unused plugins; append `!` to
" auto-approve removal
" "
" " see :h vundle for more details or wiki for FAQ
" " Put your non-Plugin stuff after this line


"colo slate
colo Tomorrow-Night-Eighties
syntax on

set number
highlight LineNr ctermfg=grey

set foldmethod=syntax
set foldlevel=99

" Use spaces instead of tabs
set expandtab

set shiftwidth=2
set softtabstop=2

" Enable filetype plugins
filetype plugin on
filetype indent on

" Change ruler format
" set rulerformat=%l,%v
" Always show current position
" set ruler

" Always show the status line
set laststatus=2
" format the status line
set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ \ %l\:%c

"" open all command line arguments in new tagpage
"autocmd VimEnter * tab all
"" creates a new last tabpage for any buffer that is created
"autocmd BufAdd * exe 'tablast | tabe "' . expand( "<afile") .'"'

" set file explorer to display at NerdTree's file tree style
let g:netrw_liststyle=3

" Map for clang format
map <C-K> :pyf ~/.vim/clang-format.py<CR>
imap <C-K> <c-o>:pyf ~/.vim/clang-format.py<CR>

" Copy and paste with clipboard
map <F2> :.w !pbcopy<CR><CR>
map <F3> :r !pbpaste<CR>

" toggle Tarball window
nmap <F8> :TagbarToggle<CR>

" map F9 key to run make
map <F9> :make<CR>

" Returns true if paste mode is enabled
function! HasPaste()
    if &paste
        return 'PASTE MODE  '
    en
    return ''
endfunction

set tabpagemax=15
if exists("+showtabline")
  function! MyTabLine()
    let s = ''
    let wn = ''
    let t = tabpagenr()
    let i = 1
    while i <= tabpagenr('$')
      let buflist = tabpagebuflist(i)
      let winnr = tabpagewinnr(i)
      let s .= '%' . i . 'T'
      let s .= (i == t ? '%1*' : '%2*')
      let s .= ' '
      let wn = tabpagewinnr(i,'$')

      let s .= '%#TabNum#'
      let s .= i
      " let s .= '%*'
      let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
      let bufnr = buflist[winnr - 1]
      let file = bufname(bufnr)
      let buftype = getbufvar(bufnr, 'buftype')
      if buftype == 'nofile'
        if file =~ '\/.'
        let file = substitute(file, '.*\/\ze.', '', '')
      endif
      else
        let file = fnamemodify(file, ':p:t')
      endif
      if file == ''
        let file = '[No Name]'
      endif
      let s .= ' ' . file . ' '
      let i = i + 1
    endwhile
    let s .= '%T%#TabLineFill#%='
    let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
    return s
  endfunction
  set stal=2
  set tabline=%!MyTabLine()
  set showtabline=1
  highlight link TabNum Special
endif


"set tabline=%!MyTabLine() " custom tab pages line
"highlight link TabNum Special
"function MyTabLine()
"  let s = '' " complete tabline goes here
"  " loop through each tab page
"  for t in range(tabpagenr('$'))
"    " set highlight
"    if t + 1 == tabpagenr()
"      let s .= '%#TabLineSel#'
"    else
"      let s .= '%#TabLine#'
"    endif
"    " set the tab page number (for mouse clicks)
"    let s .= '%' . (t + 1) . 'T'
"    let s .= ' '
"    " set page number string
"    let s .= t + 1 . ' '
"    "let s .= '%#TabNum#' . t + 1 . ' '
"    " get buffer names and statuses
"    let n = '' "temp string for buffer names while we loop and check buftype
"    let m = 0 " &modified counter
"    let bc = len(tabpagebuflist(t + 1)) "counter to avoid last ' '
"    " loop through each buffer in a tab
"    for b in tabpagebuflist(t + 1)
"      " buffer types: quickfix gets a [Q], help gets [H]{base fname}
"      " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
"      if getbufvar( b, "&buftype" ) == 'help'
"        let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
"      elseif getbufvar( b, "&buftype" ) == 'quickfix'
"        let n .= '[Q]'
"      else
"        let n .= pathshorten(bufname(b))
"      endif
"      " check and ++ tab's &modified count
"      if getbufvar( b, "&modified" )
"        let m += 1
"      endif
"      " no final ' ' added...formatting looks better done later
"      if bc > 1
"        let n .= ' '
"      endif
"      let bc -= 1
"    endfor
"    " add modified label [n+] where n pages in tab are modified
"    if m > 0
"      let s .= '[' . m . '+]'
"    endif
"    " select the highlighting for the buffer names
"    " my default highlighting only underlines the active tab
"    " buffer names.
"    if t + 1 == tabpagenr()
"      let s .= '%#TabLineSel#'
"    else
"      let s .= '%#TabLine#'
"    endif
"    " add buffer names
"    if n == ''
"      let s.= '[New]'
"    else
"      let s .= n
"    endif
"    " switch to no underlining and add final space to buffer list
"    let s .= ' '
"  endfor
"  " after the last tab fill with TabLineFill and reset tab page nr
"  let s .= '%#TabLineFill#%T'
"  " right-align the label to close the current tab page
"  if tabpagenr('$') > 1
"    let s .= '%=%#TabLineFill#%999Xclose'
"  endif
"  return s
"endfunction

""""""""""""""""""""""""""""""""" 
" plugin
""""""""""""""""""""""""""""""""" 
set runtimepath^=~/.vim/bundle/ctrlp.vim


