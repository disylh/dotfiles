if has("unix")
    let s:uname = substitute(system("uname -s"), '\n', '', '')
endif

set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" " alternatively, pass a path where Vundle should install plugins
" "call vundle#begin('~/some/path/here')
"
" " let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'

Plugin 'kien/ctrlp.vim'
Plugin 'majutsushi/tagbar.git'
Plugin 'altercation/vim-colors-solarized'
Plugin 'fatih/vim-go'
Plugin 'tpope/vim-fugitive'
Plugin 'lepture/vim-velocity'
Plugin 'mirlord/vim-dust'
if s:uname == "Darwin"
  Plugin 'gilligan/vim-lldb'
endif
" " All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" " To ignore plugin indent changes, instead use:
" "filetype plugin on
" "
" " Brief help
" " :PluginList       - lists configured plugins
" " :PluginInstall    - installs plugins; append `!` to update or just
" :PluginUpdate
" " :PluginSearch foo - searches for foo; append `!` to refresh local cache
" " :PluginClean      - confirms removal of unused plugins; append `!` to
" auto-approve removal
" "
" " see :h vundle for more details or wiki for FAQ
" " Put your non-Plugin stuff after this line

syntax on
" setting for solarized theme
"set background=dark
"let g:solarized_termcolors=256
"colorscheme solarized

"color codeschool
"colo slate
"colo Tomorrow-Night-Eighties

set number
highlight LineNr ctermfg=darkgrey

set foldmethod=syntax
set foldlevel=99

" Use spaces instead of tabs
set expandtab

set shiftwidth=2
set softtabstop=2

" highlighting search matches
set hlsearch

" Enable filetype plugins
filetype plugin on
filetype indent on

" Change ruler format
" set rulerformat=%l,%v
" Always show current position
" set ruler

" Always show the status line
set laststatus=2
" format the status line
set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ \ %l\:%c

"" open all command line arguments in new tagpage
"autocmd VimEnter * tab all
"" creates a new last tabpage for any buffer that is created
"autocmd BufAdd * exe 'tablast | tabe "' . expand( "<afile") .'"'

" set file explorer to display at NerdTree's file tree style
let g:netrw_liststyle=3

" use blowfish insteal of zip to encrypt file
set cm=blowfish

set shell+=\ --login

if s:uname == "Darwin"
  " Map for clang format
  map <C-K> :pyf ~/.vim/clang-format.py<CR>
  imap <C-K> <c-o>:pyf ~/.vim/clang-format.py<CR>
  
  " Copy and paste with clipboard
  nmap <F2> :.w !pbcopy<CR><CR>
  nmap <F3> :r !pbpaste<CR>
  vmap <F2> :w !pbcopy<CR><CR> 
  vmap <F3> :!pbcopy<CR>  
endif

if has("autocmd")
  " Auto-clean fugitive buffers
  autocmd BufReadPost fugitive://* set bufhidden=delete
endif

" toggle Tarball window
nmap <F8> :TagbarToggle<CR>

" map F9 key to run make
map <F9> :make<CR>

" buffer access
set wildchar=<Tab> wildmenu wildmode=full

let c = 1
while c <= 99
  execute "nnoremap " . c . "gb :" . c . "b\<CR>"
  let c += 1
endwhile

" Returns true if paste mode is enabled
function! HasPaste()
    if &paste
        return 'PASTE MODE  '
    en
    return ''
endfunction

set tabpagemax=15
if exists("+showtabline")
  function! MyTabLine()
    let s = ''
    let wn = ''
    let t = tabpagenr()
    let i = 1
    while i <= tabpagenr('$')
      let buflist = tabpagebuflist(i)
      let winnr = tabpagewinnr(i)
      let s .= '%' . i . 'T'
      let s .= (i == t ? '%1*' : '%2*')
      let s .= ' '
      let wn = tabpagewinnr(i,'$')

      let s .= '%#TabNum#'
      let s .= i
      " let s .= '%*'
      let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
      let bufnr = buflist[winnr - 1]
      let file = bufname(bufnr)
      let buftype = getbufvar(bufnr, 'buftype')
      if buftype == 'nofile'
        if file =~ '\/.'
        let file = substitute(file, '.*\/\ze.', '', '')
      endif
      else
        let file = fnamemodify(file, ':p:t')
      endif
      if file == ''
        let file = '[No Name]'
      endif
      let s .= ' ' . file . ' '
      let i = i + 1
    endwhile
    let s .= '%T%#TabLineFill#%='
    let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
    return s
  endfunction
  set stal=2
  set tabline=%!MyTabLine()
  set showtabline=1
  highlight link TabNum Special
endif

let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
    \ }

"set tabline=%!MyTabLine() " custom tab pages line
"highlight link TabNum Special
"function MyTabLine()
"  let s = '' " complete tabline goes here
"  " loop through each tab page
"  for t in range(tabpagenr('$'))
"    " set highlight
"    if t + 1 == tabpagenr()
"      let s .= '%#TabLineSel#'
"    else
"      let s .= '%#TabLine#'
"    endif
"    " set the tab page number (for mouse clicks)
"    let s .= '%' . (t + 1) . 'T'
"    let s .= ' '
"    " set page number string
"    let s .= t + 1 . ' '
"    "let s .= '%#TabNum#' . t + 1 . ' '
"    " get buffer names and statuses
"    let n = '' "temp string for buffer names while we loop and check buftype
"    let m = 0 " &modified counter
"    let bc = len(tabpagebuflist(t + 1)) "counter to avoid last ' '
"    " loop through each buffer in a tab
"    for b in tabpagebuflist(t + 1)
"      " buffer types: quickfix gets a [Q], help gets [H]{base fname}
"      " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
"      if getbufvar( b, "&buftype" ) == 'help'
"        let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
"      elseif getbufvar( b, "&buftype" ) == 'quickfix'
"        let n .= '[Q]'
"      else
"        let n .= pathshorten(bufname(b))
"      endif
"      " check and ++ tab's &modified count
"      if getbufvar( b, "&modified" )
"        let m += 1
"      endif
"      " no final ' ' added...formatting looks better done later
"      if bc > 1
"        let n .= ' '
"      endif
"      let bc -= 1
"    endfor
"    " add modified label [n+] where n pages in tab are modified
"    if m > 0
"      let s .= '[' . m . '+]'
"    endif
"    " select the highlighting for the buffer names
"    " my default highlighting only underlines the active tab
"    " buffer names.
"    if t + 1 == tabpagenr()
"      let s .= '%#TabLineSel#'
"    else
"      let s .= '%#TabLine#'
"    endif
"    " add buffer names
"    if n == ''
"      let s.= '[New]'
"    else
"      let s .= n
"    endif
"    " switch to no underlining and add final space to buffer list
"    let s .= ' '
"  endfor
"  " after the last tab fill with TabLineFill and reset tab page nr
"  let s .= '%#TabLineFill#%T'
"  " right-align the label to close the current tab page
"  if tabpagenr('$') > 1
"    let s .= '%=%#TabLineFill#%999Xclose'
"  endif
"  return s
"endfunction

""""""""""""""""""""""""""""""""" 
" plugin
""""""""""""""""""""""""""""""""" 
" ctrlp
set wildignore+=*/tmp/*,*.so,*.swp,*.zip
set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe


